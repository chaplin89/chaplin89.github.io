<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Car Hacking 101 | chaplinspace </title> <meta name="description" content=" Blog about hacking and other nasty things. "> <meta name="keywords" content="hacking, reverse-engineering, coding, programming"> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <!-- Social: Facebook / Open Graph --> <meta property="og:type" content="article"> <meta property="article:author" content="chaplin89"> <meta property="article:section" content=""> <meta property="article:tag" content=""> <meta property="article:published_time" content="2019-05-30 00:00:00 +0200"> <meta property="og:url" content="https://chaplin89.github.io/2019/Car-hacking-101/"> <meta property="og:title" content=" Car Hacking 101 | chaplinspace "> <meta property="og:image" content="https://chaplin89.github.io"> <meta property="og:description" content=" Blog about hacking and other nasty things. "> <meta property="og:site_name" content="chaplin89"> <meta property="og:locale" content="en_US"> <!-- Social: Twitter --> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:site" content="chaplinspace"> <meta name="twitter:title" content=" Car Hacking 101 | chaplinspace "> <meta name="twitter:description" content=" Blog about hacking and other nasty things. "> <meta name="twitter:image:src" content="https://chaplin89.github.io"> <!-- Social: Google+ / Schema.org --> <meta itemprop="name" content=" Car Hacking 101 | chaplinspace "> <meta itemprop="description" content=" Blog about hacking and other nasty things. "> <meta itemprop="image" content="https://chaplin89.github.io"> <!-- Canonical link tag --> <link rel="canonical" href="https://chaplin89.github.io/2019/Car-hacking-101/"> <link rel="alternate" type="application/rss+xml" title="chaplinspace" href="https://chaplin89.github.io/feed.xml"> <!-- rel prev and next --> <link href="https://chaplin89.github.io/assets/css/all.css" rel="stylesheet"> <link rel="stylesheet" href="https://chaplin89.github.io/assets/css/main.css"> <script text/javascript src="https://chaplin89.github.io/assets/js/jquery-3.4.1.slim.min.js" > </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: [ "MathMenu.js", "MathZoom.js", "AssistiveMML.js", "a11y/accessibility-menu.js" ], jax: ["input/TeX", "output/CommonHTML"], TeX: { extensions: [ "AMSmath.js", "AMSsymbols.js", "noErrors.js", "noUndefined.js", ] } }); </script> <!-- MathJax --> <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script> <script> $(document).ready(function () { jQuery('.fa-bars').on('click', function () { jQuery('.left').toggleClass("active"); }); }); </script> </head> <body> <div class="wrapper"> <div class="header"> <h1 class="logo"><a href="https://chaplin89.github.io/">chaplin<span>space</span></a> </h1> <i class="fas fa-bars"></i> </div> <div class="left"> <header class="site-header"> <div class="container"> <h1 class="logo"><a href="https://chaplin89.github.io/">chaplin<span>space</span></a> </h1> <nav class="navbar"> <ul> <a href="https://chaplin89.github.io/"> <li>Home</li> </a> <a href="https://chaplin89.github.io/about"> <li>About me</li> </a> <a href="https://chaplin89.github.io/feed.xml" target="_blank"> <li>RSS</li> </a> </ul> </nav> <div class="intro"> <p class="lead">Hi, I'm Marco and this blog talks about hacking and other nasty things.</p> <a class="social" href="https://www.github.com/chaplin89"><i class="fab fa-github"></i></a> <div class="donation"> <a href="https://www.savethechildren.org/us/about-us/why-save-the-children"> Did I help? Click here to know what to do. </a> </div> </div> </div> </header> </div> <div class="main"> <article class="post container" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <p class="post-meta"><time datetime="2019-05-30T00:00:00+02:00" itemprop="datePublished">May 30, 2019</time></p> <h1 class="post-title" itemprop="name headline">Car Hacking 101</h1> </header> <div class="post-content" itemprop="articleBody"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"><a href="#introduction">Introduction</a></li> <li class="toc-entry toc-h1"><a href="#where-to-start">Where to start?</a></li> <li class="toc-entry toc-h1"><a href="#whats-obd">What’s OBD?</a> <ul> <li class="toc-entry toc-h2"><a href="#whats-obd-ii">What’s OBD-II?</a></li> <li class="toc-entry toc-h2"><a href="#whats-the-obd-ii-protocol">What’s the OBD-II protocol?</a></li> <li class="toc-entry toc-h2"><a href="#how-data-is-transmitted-over-the-obd-ii-port">How data is transmitted over the OBD-II port?</a></li> </ul> </li> <li class="toc-entry toc-h1"><a href="#what-is-can">What is CAN?</a> <ul> <li class="toc-entry toc-h2"><a href="#1-physical-layer">1. Physical Layer</a></li> <li class="toc-entry toc-h2"><a href="#2-datalink-collision-and-priorities">2. Datalink, Collision, and priorities</a></li> <li class="toc-entry toc-h2"><a href="#3-datalink-frames">3. Datalink, Frames</a></li> <li class="toc-entry toc-h2"><a href="#how-can-is-used-inside-a-car">How CAN is used inside a car?</a></li> <li class="toc-entry toc-h2"><a href="#how-the-obd-ii-protocol-is-encoded-in-a-can-bus">How the OBD-II protocol is encoded in a CAN bus?</a></li> </ul> </li> <li class="toc-entry toc-h1"><a href="#which-component-to-use-for-interfacing-with-a-car">Which component to use for interfacing with a car?</a> <ul> <li class="toc-entry toc-h2"><a href="#all-in-one-obd-ii-to-usbwifibluetooth-adapter">All-in-one OBD-II to USB/WiFi/Bluetooth adapter</a></li> <li class="toc-entry toc-h2"><a href="#can-to-something-adapters">CAN to something adapters</a></li> <li class="toc-entry toc-h2"><a href="#rs485-adapters">RS485 adapters</a></li> </ul> </li> </ul><hr> <p><em>This is still a work in progress!</em></p> <hr> <h1 id="introduction"> <a class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h1> <p>In this post, I’m trying to put together some information that can be useful to a person trying to hack a car. It comes without the promise to be complete or correct. What follows is just a collection of questions I had while approaching this world and my attempt to answer said questions.</p> <h1 id="where-to-start"> <a class="anchor" href="#where-to-start" aria-hidden="true"><span class="octicon octicon-link"></span></a>Where to start?</h1> <p>There are different ways to interface with a car that differs in complexity and cost. One simple way is using the OBD-II port, which is usually found in the car’s driver side.</p> <h1 id="whats-obd"> <a class="anchor" href="#whats-obd" aria-hidden="true"><span class="octicon octicon-link"></span></a>What’s OBD?</h1> <p>OBD stands for on-board-diagnostic. It’s a general term that refers to the self-diagnostic and reporting capabilities of a vehicle.</p> <p>There exist different standards related to OBD. The most common nowadays is ODB-II, for cars made from ~2000 onwards.</p> <h2 id="whats-obd-ii"> <a class="anchor" href="#whats-obd-ii" aria-hidden="true"><span class="octicon octicon-link"></span></a>What’s OBD-II?</h2> <p>OBD-II is a group of ISO/SAE standards that define things like:</p> <ul> <li>the shape of a connector (sometimes referred to with the name of the standard, SAE J962)</li> <li>its pinout</li> <li>The format of the message exchanged</li> <li>common “trouble code”</li> <li>service IDs</li> </ul> <p>I’ll refer to the latter 3 points as the “<strong>OBD-II protocol</strong>”.</p> <h2 id="whats-the-obd-ii-protocol"> <a class="anchor" href="#whats-the-obd-ii-protocol" aria-hidden="true"><span class="octicon octicon-link"></span></a>What’s the OBD-II protocol?</h2> <p>As said, it’s a protocol made to access diagnostic information of a car.</p> <p>It’s a straightforward protocol based on two key concepts:</p> <ul> <li>Service ID</li> <li>Protocol ID</li> </ul> <p>Each service ID is associated with several protocol IDs, and each combination of service IDs and protocol IDs provides access to a piece of specific diagnostic information.</p> <p>The protocol allows a device to make a query using a tuple of service ID and protocol ID (encoded in a way that is explained later). On the other side, an OBD-II aware ECU will respond to the query with the appropriate information.</p> <p>Some service IDs/protocol IDs are fixed (and public) others are manufacturer specific.</p> <p><a href="https://en.wikipedia.org/wiki/OBD-II_PIDs#Service_02">Wikipedia</a> contains a handy list of common service IDs/protocol IDs.</p> <h2 id="how-data-is-transmitted-over-the-obd-ii-port"> <a class="anchor" href="#how-data-is-transmitted-over-the-obd-ii-port" aria-hidden="true"><span class="octicon octicon-link"></span></a>How data is transmitted over the OBD-II port?</h2> <p>While OBD-II specifies a common way to retrieve diagnostic information from the car, it provides different choices for the lowest level details of the communication, like what is the layer 1 to use to exchange these messages, but it obliges the manufacturers to make this detail public.</p> <p>In practice, for cars made after 2006, chances are they are using CAN.</p> <p>As for the pinout, OBD-II connectors have 16 pins: some of them are manufacturer-specific some of them are standard.</p> <p><img src="/assets/images/obd2_connector.png" alt="OBD-II Connector" class="center-image"></p> <p>As for the standard pins:</p> <ul> <li>2-9: PWM/VPW, Respectively, +/-</li> <li>4-5: Chassis/signal ground</li> <li>6-14: CAN+/CAN-</li> <li>7-15: K/L Line</li> <li>16: Vcc</li> </ul> <p>Variable pulse width (VPW), Pulse width modulation (PWM), Keyword Protocol (K/L) are usually found on very old cars (with some exception, like general motors). As I said, CAN is the most common, hence you’ll end up using only 6-14 pins most of the time.</p> <p>As for the manufacturer-specific pin, they are, well, manufacturer-specific. Not too much to say here except that sometimes connected pins can be found just by seeing the connector.</p> <p>Here is an example of the OBD-II connector in a real car. It’s easy to spot which pins are wired and which are not:</p> <p><img src="/assets/images/OBDII_REAL.jpg" alt="OBD-II on a real car" class="center-image"></p> <p>Understanding what’s going on these manufacturer-specific pins is, of course, another story. In some cases, a multimeter/oscilloscope can be useful (if you know what you are looking for); in other cases, you can find some leaked service manuals of the car online.</p> <p>On these pins, you can find, for example, another CAN network.</p> <h1 id="what-is-can"> <a class="anchor" href="#what-is-can" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is CAN?</h1> <p>When we talk about CAN, we are talking about ISO 11898.</p> <p>ISO 11898 is divided into ISO 11898-1 (data link layers), ISO 11898-2 (physical layer) and ISO 11898-3 (physical layer for fault-tolerant CAN).</p> <p>CAN it’s a standard for serial communication made to be tolerant to noises. On its lowest level, it uses <a href="https://en.wikipedia.org/wiki/RS-485">RS485</a>, but while RS485 regards only the physical layer, CAN it’s specifying also the data link layer.</p> <p>What follows is a summary of the key concept of CAN. They can be useful to understand how ECUs and devices communicate, but it’s not mandatory to understand those detail to hack a car, as some kind of adapter normally manages them (as explained below). Feel free to skip this part.</p> <h2 id="1-physical-layer"> <a class="anchor" href="#1-physical-layer" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Physical Layer</h2> <p>As said, for the electrical part CAN is essentially RS485.</p> <p>CAN uses 2 wires and differential signaling. This means the two signals present on the wires are complementary, e.g.: if the tension on the first wire drop of 2V, the tension on the second wire surge of 2V. This is shown to have a good rejection of noise.</p> <h2 id="2-datalink-collision-and-priorities"> <a class="anchor" href="#2-datalink-collision-and-priorities" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Datalink, Collision, and priorities</h2> <p>Conflicts are managed by introducing the concept of “dominant” (== 0) and “recessive” (== 1) bits.</p> <p>Recessive bits are not visible on the bus if some other device is transmitting a dominant bit at the same time. This can be useful both for collision detection and managing priorities.</p> <p>Collision detection is done by probing the channel while transmitting. If the sender is sending a recessive bit but probe a dominant bit, he has the certainty that a collision occurred.</p> <p>Other possible collisions go unnoticed.</p> <p>These collisions are:</p> <ul> <li>2 dominant bit sent at the same time</li> <li>2 recessive bit sent at the same time</li> <li>sending a dominant bit while another device is sending a recessive bit</li> </ul> <p>When a device notices a collision, it will stop the transmission.</p> <p>Because of the structure of CAN messages, at the beginning of each message, there is the transmitter ID. From what was said, it can be inferred that the sender with a lower ID will have more priority on the bus, as they’ll have an occurrence of a dominant bit earlier in the ID.</p> <h2 id="3-datalink-frames"> <a class="anchor" href="#3-datalink-frames" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Datalink, Frames</h2> <p>There are 4 kinds of frames specified by the CAN protocol:</p> <ol> <li> <strong>Data</strong>: Used to transmit data.</li> <li> <strong>Remote</strong>: Used to request data transmission to another node.</li> <li> <strong>Error</strong>: Used to signal an error.</li> <li> <strong>Overload</strong>: Used to delay a data or a remote frame.</li> </ol> <p>The format of the telegram on the wire is always the same, regardless of the frame type:</p> <table> <thead> <tr> <th>Name</th> <th>Lenght</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>Start</td> <td>1</td> <td>Start of the telegram</td> </tr> <tr> <td>ID</td> <td>11</td> <td>Message ID</td> </tr> <tr> <td>RTR</td> <td>1</td> <td>Request to transmit (dominant for data frames, recessive for remote frames)</td> </tr> <tr> <td>IDE</td> <td>1</td> <td>Additional identification bit</td> </tr> <tr> <td>R0</td> <td>1</td> <td>Reserved</td> </tr> <tr> <td>DLC</td> <td>4</td> <td>Lenght of the data field (bytes)</td> </tr> <tr> <td>Data</td> <td>4-8 B</td> <td>Data</td> </tr> <tr> <td>CRC</td> <td>15</td> <td> </td> </tr> <tr> <td>DCRC</td> <td>1</td> <td>Always a recessive bit</td> </tr> <tr> <td>ACK</td> <td>1</td> <td>Recessive in the transmitter, dominant in receivers</td> </tr> <tr> <td>DACK</td> <td>1</td> <td>ACK delimiter; Always a recessive bit</td> </tr> <tr> <td>EOF</td> <td>7</td> <td>All recessive bits</td> </tr> </tbody> </table> <h2 id="how-can-is-used-inside-a-car"> <a class="anchor" href="#how-can-is-used-inside-a-car" aria-hidden="true"><span class="octicon octicon-link"></span></a>How CAN is used inside a car?</h2> <p>CAN buses are used to connect devices to ECUs and ECUs to other ECUs.</p> <p>I guess it’s safe to say that most car has at least 2 different CAN networks: the first, slow and fault-tolerant, is for the “serious” and critical stuff. The second, faster, is for the infotainment-ish stuff.</p> <ul> <li>Example of 1st kind of messages: “<strong>Key is inserted</strong>”, “<strong>Immobilizer is off</strong>”</li> <li>Example of 2nd kind of messages: “<strong>Air-conditioning is ON</strong>”, “<strong>Radio is on 98.5MHz</strong>”</li> </ul> <p>For cars that use CAN, At least one of the networks presents inside a car is exposed through an OBD-II connector using standard pins 6-14. The ECUs connected on these pins can handle the “OBD-II protocol”, as the whole purpose of the OBD-II port is to provide a common way to access the diagnostic of a car.</p> <p>In some cases, even a second CAN bus is exposed using manufacturer-specific pins. The messages exchanged on this second network are highly dependent on the manufacturer.</p> <h2 id="how-the-obd-ii-protocol-is-encoded-in-a-can-bus"> <a class="anchor" href="#how-the-obd-ii-protocol-is-encoded-in-a-can-bus" aria-hidden="true"><span class="octicon octicon-link"></span></a>How the OBD-II protocol is encoded in a CAN bus?</h2> <p>For cars that use CAN, every request for OBD information is made to the address 0x07DF. In the data field, the first byte identifies the service ID, the second byte identifies the protocol ID. That’s everything that is needed to make an OBD-II query.</p> <p>Because there can exist multiple ECUs, the address 0x07DF act as a broadcast address. Every OBD-II aware ECUs will listen to this address and respond to the message using its ID.</p> <p>The response length can vary depending on the information asked.</p> <h1 id="which-component-to-use-for-interfacing-with-a-car"> <a class="anchor" href="#which-component-to-use-for-interfacing-with-a-car" aria-hidden="true"><span class="octicon octicon-link"></span></a>Which component to use for interfacing with a car?</h1> <p>Here we’re getting to the meat and potato of car-hacking. Different choices are depending on what goal you’re trying to achieve. I’ll explore some of them.</p> <h2 id="all-in-one-obd-ii-to-usbwifibluetooth-adapter"> <a class="anchor" href="#all-in-one-obd-ii-to-usbwifibluetooth-adapter" aria-hidden="true"><span class="octicon octicon-link"></span></a>All-in-one OBD-II to USB/WiFi/Bluetooth adapter</h2> <p>These devices easily allow you to connect with an OBD-II port. At their core, they have an OBD-II to RS232 ICs and a WiFi/Bluetooth transceiver or a USB controller.</p> <p>There exist many kinds of these devices, but most of them are based on <a href="https://www.elmelectronics.com/products/ics/obd/">ELM327</a> ICs. Even if there exists other OBD-II to RS232 ICs (like the <a href="https://www.obdsol.com/solutions/chips/stn1110/">STN1110</a>, that seems to be also more hacker-friendly), ELM327 is the standard “de-facto” in this field. Other chips try to be compatible with the ELM327’s AT interface (see below), due to the numerous applications that are made for it.</p> <p><a href="https://en.wikipedia.org/wiki/ELM327">ELM327</a> is a PIC microcontroller programmed in a certain way to provide a high-level interface to the OBD-II protocol. It supports every possible protocol specified by OBD-II standards while other ELM32x support only a specific subset.</p> <p>Interacting with ELM327 is done via <a href="https://en.wikipedia.org/wiki/Hayes_command_set">AT commands</a>. The list of possible AT commands supported by ELM327 can be found on the <a href="https://www.elmelectronics.com/wp-content/uploads/2017/01/ELM327DS.pdf">manufacturer website</a>.</p> <p>Note that depending on the firmware installed on the device, it may or may not support all the AT commands. ELM Electronics provides a <a href="https://www.elmelectronics.com/wp-content/uploads/2017/01/AT_Command_Table.pdf">nice comparison</a> of feature between versions.</p> <p>This is a very important thing from the hacker perspective because some of these features are <strong>really</strong> important for your nasty hacking purposes (like sniffing).</p> <p>Another important thing to consider is that there exists 2 variant of ELM327:</p> <ul> <li> <strong>Original EML327</strong>: this is the version made by <a href="https://www.elmelectronics.com/">ELM Electronic</a>, which is an overall nice IC and a very simple way to interact with the OBD-II port.</li> <li> <strong>Crappy Chinese ELM327 clone</strong>: sometimes also found with the name “ELM327 mini”, it’s a crappy clone of the former adapter. From what it can be read from <a href="https://en.wikipedia.org/wiki/ELM327#Pirate_clones">wikipedia</a>, the first version of ELM327 does not come with copy protections and this made very simple for hackers to dump the firmware and re-use it on other hardware. It can be difficult to distinguish an original ELM327 from an ELM327 clone, here are some advice: <ul> <li> <strong>If you’re going to buy one of them</strong>: as a rule of thumb, if it cost less than 10-15 bucks or it is called “ELM327 mini” don’t waste your money. Consider that, at the time of writing, the ELM327 price at retail is 21$ on the manufacturer website. Always read reviews of the product you’re going to buy or ask directly to the seller.</li> <li> <strong>If you already own one of them in a WiFi/Bluetooth variant</strong>: try using this <a href="https://play.google.com/store/apps/details?id=com.applagapp.elm327identifier&amp;hl=it">app</a> to see which capabilities the adapter has and don’t be fooled by the firmware version: it’s easy to find crappy Chinese stuff that claims to be “v2.3” but in fact they fail to provide all the capabilities required even by v1.0.</li> </ul> </li> </ul> <h2 id="can-to-something-adapters"> <a class="anchor" href="#can-to-something-adapters" aria-hidden="true"><span class="octicon octicon-link"></span></a>CAN to something adapters</h2> <p>ELM327 proved to be a very simple and cheap way to interact with an ECU. Unfortunately, ELM327 is meant to provide access to the diagnostics of the car, not to be a hacker-friendly device and it will mask most of the things that are happening on the lowest levels.</p> <p>A better choice could be to use a CAN-to-* adapter, as it provides raw and unfiltered access to the bus.</p> <p>For my experiments, I used an MCP2515 CAN to SPI adapter connected to a Raspberry.</p> <h2 id="rs485-adapters"> <a class="anchor" href="#rs485-adapters" aria-hidden="true"><span class="octicon octicon-link"></span></a>RS485 adapters</h2> <p>While it is theoretically possible to use an RS485-to-something adapter, I don’t have any experience on this.</p> <p>I can only guess that it should be way more difficult to make things work with said adapter, as a CAN-aware adapter is normally made by a transceiver and a controller. With an RS485 adapter, you get the transceiver (that handle most of the layer 1), but you don’t get the controller (that handle the layer 2 and part of the 1). Because of this, you’ll need extra software to manage things like bit-stuffing and dominant/recessive logic.</p> <aside class="share"> <p>If you liked this article and think others should read it, please share it on <a href="http://twitter.com/share?text=Car Hacking 101&amp;url=https://chaplin89.github.io/2019/Car-hacking-101/&amp;via=chaplinspace" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">Twitter</a> or <a href="https://www.facebook.com/sharer/sharer.php?u=https://chaplin89.github.io/2019/Car-hacking-101/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=235');return false;">Facebook</a>.</p> </aside> </div> </article> <aside id="comments" class="disqus"> <div class="container"> <h3><i class="icon icon-comments-o"></i> Comments</h3> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'chaplin89-github-io'; var disqus_identifier = '/2019/Car-hacking-101'; var disqus_title = 'Car Hacking 101'; var disqus_url = 'https://chaplin89.github.io/2019/Car-hacking-101/'; /*var disqus_developer = 1;*/ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript> Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a> </noscript> </div> </aside> </div> </div> <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-141216446-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> </body> </html>
